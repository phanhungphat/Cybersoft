** LÀM BACKEND THÌ PHẢI ĐẶT CÂU HỎI TẠI SAO TRƯỚC, SAU ĐÓ SẼ SO SÁNH ƯU NHƯỢC ĐIỂM

PHÂN TÍCH CSDL
Mẹo: CSDL là nơi lưu trữ csdl --> DỮ LIỆU LƯU TRỮ SẼ ĐÁP ỨNG MỘT TÍNH NĂNG BẤT KỲ TRÊN TỪNG GIAO DIỆN
==> CÁCH PHÂN TÍCH DỄ NHẤT SẼ LÀ "ĐI TÌM ĐỐI TƯỢNG" trên từng màn hình
==> SAU KHI CÓ ĐỐI TƯỢNG XONG XÁC ĐỊNH THUỘC TÍNH
--> Khoá chính sẽ là trường nào (thông thường là 'ID')
--> dùng draw.io vẽ phác thảo ra các bảng trong csdl
--> bảng nào có quan hệ với nhiều bảng thì chắc chắn bảng đó là bảng trung gian.
--> Bảng nào cũng phải có "trạng thái" (chưa bắt đầu, đang thực hiện, hoàn thành, huỷ)
-> ví dụ "trạng thái dự án" và "trạng thái công việc" khác nhau <-- "task công việc" xong nhưng chưa chắc "dự án" sẽ xong.
--> Nếu có hẳn 1 trang thống kê --> làm thêm 1 "bảng status" nữa --> trong các bảng khác sẽ có id_status làm khoá ngoại --> khi làm thống kê thì lấy dữ liệu của bảng status liên kết với các bảng khác VÀ STATUS THÌ ĐÔI KHI KHÔNG PHẢI LÚC NÀO CŨNG LÀM ĐỘNG.
--> DATABASE trong thực tế khi tạo sẽ có thêm từ 2 tới 3 cột (trong đó có 2 cột sẽ thêm) --> cột "audit" để "ghi log" - activity log a.k.a secure log; data log, access log --> có thể tương quan ra là "ngày tạo - create date" và "ngày update - update date" và "người tạo"; một số công ty khác kỹ hơn sẽ có thêm cột "dữ liệu mới", "dữ liệu cũ".
Ví Dụ 1:
TÍNH NĂNG LOGIN
- Màn hình Login ==> tính năng login
==> đối tượng "sử dụng": 'người dùng' a.k.a 'user'
==> xác định "thuộc tính" của 'đối tượng' --> màn hình login thì có 2 trường 'email' và 'password'
==> Sau khi xác định được thuộc tính thì "hình dung business sẽ xử lý trên màn hình đó" và bảng đối tượng xuất hiện trong csdl sẽ được xử lý như thế nào ==> một business sẽ gắn liền với một câu truy vấn hoặc nhiều câu truy vấn.
==> xử lý "bad case" và "happy case" ==> "tồn tại" hay "không tồn tại" các trường mà business sẽ phải xử lý trên màn hình đó ==> hình dung câu truy vấn tới csdl.
** KHI PHÂN TÍCH GẶP 1 SELECT BOX HAY CHECK BOX THÌ TÁCH RA THÀNH 1 BẢNG
--> VÌ THÔNG TIN ĐÓ LÀ THÔNG TIN XỬ LÝ ĐỘNG
-> NỘI DUNG ĐỀ MỤC SELECT BOX HAY CHECK BOX LÀ MỘT ĐỐI TƯỢNG
** NẾU TRONG CÙNG 1 MÀN HÌNH MÀ TÌM THẤY ĐƯỢC NHIỀU HƠN 2 HOẶC NHIỀU HƠN NỮA THÌ CÁC BẢNG ĐÓ SẼ CÓ QUAN HỆ VỚI NHAU.
Ví dụ: 1 User chỉ có 1 Role, nhưng 1 Role thì sẽ có nhiều khoá ngoại, bên nào nhiều thì bên đó giữ khoá ngoại.
- Nguyên tắc phân tích csdl: càng ít bảng càng tốt.




DESIGN PATTERN
- controller: dùng để định nghĩa đường dẫn
- repository: thực thi câu truy vấn và trả kết quả, ko được phép xử lý logic code
- service: xử lý logic code cho controller

=================================================================================
Cookie: lưu trên máy người dùng
Session: Lưu trên RAM của Server



DESIGN PATTER
- Code tính năng phải chia logic ra, chia làm các phần khác nhau để quản lý
- Design Pattern là chia nhỏ file và chia nhỏ source code
- Không có quy định design pattern cụ thể lúc làm thực tế


+ Xài Stategy Design Pattern
-- Controller <=> Service <=> Repository
--> Controller: Chỉ khai báo đường dẫn mà nó sẽ xử lý và nhận tham số người dùng truyền lên
--> Service: Dùng để xử lý logic code cho các chức năng của Controller (Tức là nhận tham số của controller và đem đi xử lý)
--> Repository: Thực thi câu truy vấn và trả ra kết quả của câu truy vấn (Lưu ý: không xử lý logic code ở đây)




Thao tác "Create"
--> Phân tích theo hành vi người dùng
--> Happy Case
- định nghĩa đường dẫn servlet
- xác định câu truy vấn
- quy định tham số client nhập vào
- thực hiện câu truy vấn

SPRINGBOOT - INTRODUCTION - BUỔI 30
1. PHÂN BIỆT "FRAMEWORK" VÀ "LIBRARY"
- FRAMEWORK: là tập hợp nhiều thư viện, xây dựng sẵn nhiều tính năng có sẵn, khi cần là lấy ra xài, SpringBoot khắc phục điểm yếu, không ép dev tuân thủ nguyên tắc; hỗ trợ nhiều tiêu chuẩn bảo mật
- LIBRARY: chỉ là "thư viện" - chỉ giải quyết 1 vài tính năng hay xài, 1 vấn đề nhỏ, muốn sử dụng thì phải tự import/insert 

Kiến trúc của Framework Spring luôn có:
- Client --> Security --> Controller Layer (Nơi định nghĩa đường dẫn) --> Business Layer (tương ứng với lại tầng Service)--> Persistence Layer (Tương ứng với Repository)--> Database 

- tại sao sử dụng microservice ?
--> Để cho các tính năng đều chạy độc lập với nhau.
--> 1 Service chết thì các tính năng khác vẫn còn chạy được

SpringBoot giúp xây dựng trang web
- Tại sao lại chia FE và BE:
--> FE xử lý giao diện
--> BE xử lý database, bảo mật, làm trung gian để tương tác với database, tránh bị hack --> cái nặng của BE là xử lý dữ liệu <---- BE nặng về nghiệp vụ ---> Xử lý dữ liệu được quy định mà hầu như các ngôn ngữ đều hỗ trợ --> Kiểu dữ liệu nguyên thuỷ --> Vì kiểu dữ liệu nguyên thuỷ là kiểu dữ liệu sơ khai --> Kiểu String

0:37:20
