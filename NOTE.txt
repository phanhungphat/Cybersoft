** LÀM BACKEND THÌ PHẢI ĐẶT CÂU HỎI TẠI SAO TRƯỚC, SAU ĐÓ SẼ SO SÁNH ƯU NHƯỢC ĐIỂM

PHÂN TÍCH CSDL
Mẹo: CSDL là nơi lưu trữ csdl --> DỮ LIỆU LƯU TRỮ SẼ ĐÁP ỨNG MỘT TÍNH NĂNG BẤT KỲ TRÊN TỪNG GIAO DIỆN
==> CÁCH PHÂN TÍCH DỄ NHẤT SẼ LÀ "ĐI TÌM ĐỐI TƯỢNG" trên từng màn hình
==> SAU KHI CÓ ĐỐI TƯỢNG XONG XÁC ĐỊNH THUỘC TÍNH
--> Khoá chính sẽ là trường nào (thông thường là 'ID')
--> dùng draw.io vẽ phác thảo ra các bảng trong csdl
--> bảng nào có quan hệ với nhiều bảng thì chắc chắn bảng đó là bảng trung gian.
--> Bảng nào cũng phải có "trạng thái" (chưa bắt đầu, đang thực hiện, hoàn thành, huỷ)
-> ví dụ "trạng thái dự án" và "trạng thái công việc" khác nhau <-- "task công việc" xong nhưng chưa chắc "dự án" sẽ xong.
--> Nếu có hẳn 1 trang thống kê --> làm thêm 1 "bảng status" nữa --> trong các bảng khác sẽ có id_status làm khoá ngoại --> khi làm thống kê thì lấy dữ liệu của bảng status liên kết với các bảng khác VÀ STATUS THÌ ĐÔI KHI KHÔNG PHẢI LÚC NÀO CŨNG LÀM ĐỘNG.
--> DATABASE trong thực tế khi tạo sẽ có thêm từ 2 tới 3 cột (trong đó có 2 cột sẽ thêm) --> cột "audit" để "ghi log" - activity log a.k.a secure log; data log, access log --> có thể tương quan ra là "ngày tạo - create date" và "ngày update - update date" và "người tạo"; một số công ty khác kỹ hơn sẽ có thêm cột "dữ liệu mới", "dữ liệu cũ".
Ví Dụ 1:
TÍNH NĂNG LOGIN
- Màn hình Login ==> tính năng login
==> đối tượng "sử dụng": 'người dùng' a.k.a 'user'
==> xác định "thuộc tính" của 'đối tượng' --> màn hình login thì có 2 trường 'email' và 'password'
==> Sau khi xác định được thuộc tính thì "hình dung business sẽ xử lý trên màn hình đó" và bảng đối tượng xuất hiện trong csdl sẽ được xử lý như thế nào ==> một business sẽ gắn liền với một câu truy vấn hoặc nhiều câu truy vấn.
==> xử lý "bad case" và "happy case" ==> "tồn tại" hay "không tồn tại" các trường mà business sẽ phải xử lý trên màn hình đó ==> hình dung câu truy vấn tới csdl.
** KHI PHÂN TÍCH GẶP 1 SELECT BOX HAY CHECK BOX THÌ TÁCH RA THÀNH 1 BẢNG
--> VÌ THÔNG TIN ĐÓ LÀ THÔNG TIN XỬ LÝ ĐỘNG
-> NỘI DUNG ĐỀ MỤC SELECT BOX HAY CHECK BOX LÀ MỘT ĐỐI TƯỢNG
** NẾU TRONG CÙNG 1 MÀN HÌNH MÀ TÌM THẤY ĐƯỢC NHIỀU HƠN 2 HOẶC NHIỀU HƠN NỮA THÌ CÁC BẢNG ĐÓ SẼ CÓ QUAN HỆ VỚI NHAU.
Ví dụ: 1 User chỉ có 1 Role, nhưng 1 Role thì sẽ có nhiều khoá ngoại, bên nào nhiều thì bên đó giữ khoá ngoại.
- Nguyên tắc phân tích csdl: càng ít bảng càng tốt.




DESIGN PATTERN
- controller: dùng để định nghĩa đường dẫn
- repository: thực thi câu truy vấn và trả kết quả, ko được phép xử lý logic code
- service: xử lý logic code cho controller

=================================================================================
Cookie: lưu trên máy người dùng
Session: Lưu trên RAM của Server



DESIGN PATTER
- Code tính năng phải chia logic ra, chia làm các phần khác nhau để quản lý
- Design Pattern là chia nhỏ file và chia nhỏ source code
- Không có quy định design pattern cụ thể lúc làm thực tế


+ Xài Stategy Design Pattern
-- Controller <=> Service <=> Repository
--> Controller: Chỉ khai báo đường dẫn mà nó sẽ xử lý và nhận tham số người dùng truyền lên
--> Service: Dùng để xử lý logic code cho các chức năng của Controller (Tức là nhận tham số của controller và đem đi xử lý)
--> Repository: Thực thi câu truy vấn và trả ra kết quả của câu truy vấn (Lưu ý: không xử lý logic code ở đây)




Thao tác "Create"
--> Phân tích theo hành vi người dùng
--> Happy Case
- định nghĩa đường dẫn servlet
- xác định câu truy vấn
- quy định tham số client nhập vào
- thực hiện câu truy vấn

SPRINGBOOT - INTRODUCTION - BUỔI 30
1. PHÂN BIỆT "FRAMEWORK" VÀ "LIBRARY"
- FRAMEWORK: là tập hợp nhiều thư viện, xây dựng sẵn nhiều tính năng có sẵn, khi cần là lấy ra xài, SpringBoot khắc phục điểm yếu, không ép dev tuân thủ nguyên tắc; hỗ trợ nhiều tiêu chuẩn bảo mật
- LIBRARY: chỉ là "thư viện" - chỉ giải quyết 1 vài tính năng hay xài, 1 vấn đề nhỏ, muốn sử dụng thì phải tự import/insert 

Kiến trúc của Framework Spring luôn có:
- Client --> Security --> Controller Layer (Nơi định nghĩa đường dẫn) --> Business Layer (tương ứng với lại tầng Service)--> Persistence Layer (Tương ứng với Repository)--> Database 

- tại sao sử dụng microservice ?
--> Để cho các tính năng đều chạy độc lập với nhau.
--> 1 Service chết thì các tính năng khác vẫn còn chạy được

SpringBoot giúp xây dựng trang web
- Tại sao lại chia FE và BE:
--> FE xử lý giao diện
--> BE xử lý database, bảo mật, làm trung gian để tương tác với database, tránh bị hack --> cái nặng của BE là xử lý dữ liệu <---- BE nặng về nghiệp vụ ---> Xử lý dữ liệu được quy định mà hầu như các ngôn ngữ đều hỗ trợ --> Kiểu dữ liệu nguyên thuỷ --> Vì kiểu dữ liệu nguyên thuỷ là kiểu dữ liệu sơ khai --> Kiểu String

Ở SpringBoot, chúng ta học cách xử lý những thứ như sau:
--> Định nghĩa đường dẫn
--> Xử lý logic đường dẫn
--> Trả ra dữ liệu

- 2 Loại thư viện: Gradle và Maven
--> Gradle nhanh hơn
--> Nhưng xài thì xài Maven --> vì nó không cache nhiều, nặng máy

- Các hỗ trợ packaging: JAR và WAR --> Chọn JAR
--> hồi xưa nếu chọn Java App thì JAR, nếu chọn Java Web thì WAR
--> chọn Jar vì tính phổ biến

Vào web "Spring initializr" --> chọn kiểu project là "Maven", Packaging là "JAR", Java với Version ỔN ĐỊNH và MỚi NHẤT (tại thời điểm ghi chú là 21); Sau đó add Dependencies chỉ chọn "Spring Web" --> Sau đó bấm Generate.

MỤC ĐÍCH CHUNG CỦA BE
--> ĐỊNH NGHĨA ĐƯỜNG DẪN --> Tạo controller
--> ĐỊNH NGHĨA THAM SỐ đường dẫn

 * Định Nghĩa đường dẫn SpringBoot, xài 2 annotation để khai báo cho SpringBoot biết là đây là định nghĩa đường dẫn
 *
 * Dùng để khai báo cho SpringBoot biết đây là nơi khai báo đường dẫn
 * @Controller: Khai báo cho Spring biết đây là nơi khai báo đường dẫn, trả về file html (Giao diện người dùng)
 * @ResponseBody: Khai báo cho Spring biết đây là nơi khai báo đường dẫn, trả về dữ liệu (JSON, XML, String, ...)
 *
 * @RestController: Khai báo cho Spring biết đây là nơi khai báo đường dẫn, trả về dữ liệu (JSON, XML, String, ...) --> Hiên tại thường hay xài JSON
 *
 * @RequestMapping: Khai báo đường dẫn
 
 CÁC THƯ MỤC QUAN TRỌNG TRONG 1 DỰ ÁN SPRINGBOOT
 - <tên thư mục gốc>/src/ : không được xoá
 - <tên thư mục gốc>/src/main : chứa logic code
 - <tên thư mục gốc>/src/main/java : định nghĩa đường dẫn, logic code
 - <tên thư mục gốc>/src/main/resources : nơi chứa các file html,css
 - <tên thư mục gốc>/src/main/resources/static/ : chứa file tĩnh --> dev ít xài
 - <tên thư mục gốc>/src/main/resources/static/templates/ : vẫn chứa html --> dev ít xài
 - <tên thư mục gốc>/src/main/resources/application.properties : file quan trọng, không được xoá, chứa thông tin cấu hình của project
 
 - <tên thư mục gốc>/src/test : nơi viết các unit test
 
 - pom.xml : thông tin metadata của project, có thể insert thêm thư viện ở cặp thẻ <dependency>; muốn add thêm thư viện mới thì vào trang web String Initializr, search thêm thư viện, sau đó bấm "explore" và kiếm cặp thẻ tương ứng với thư viện cần thêm, copy xong add vào file pom.xml
 
Bean và IOC
- Dependencies Injection là gì ?
--> NƠI LƯU TRỮ NHỮNG ĐỐI TƯỢNG ĐÃ ĐƯỢC KHAI BÁO SẴN GIÁ TRỊ, KHI CẦN THÌ LẤY XUỐNG SỬ DỤNG, KHÔNG KHỞI TẠO LẠI
--> "Khử sự phụ thuộc" --> Để khử sự phục thuộc thì sẽ xài tới tính đa hình
-> Có thể hiểu là khai báo để dùng xuyên class
--> Tạo ra những đối tượng gán sẵn giá trị, rồi sau đó có thể dùng xuyên class
--> Có thể hiểu giống như biến static --> Lưu trên RAM

Dependencies Injection là kỹ thuật là lưu trữ các đối tượng, biến đã khai báo sẵn giá trị để dùng chung, khi cần thì gọi ra sử dụng
--> Khi muốn sử dụng thì "inject" xuống
--> Trong SpringBoot thì sử dụng IOC

0:30:13 - buổi 31

--> Quy định tham số và nhận tham số


RESTFUL API
- Bộ phương thức/nguyên tắc GET, POST, PUT, DELETE dev bên ngoài rất ít tuân thủ, toàn dùng phương thức POST
- Http Status bên ngoài gặp nhiều nhất là lỗi 500 (lỗi logic hoặc được gọi là lỗi runtime/compiler)
- RESTful API kế thừa toàn bộ REST API và có thêm các nguyên tắc về HTTP Status code, các phương thức GET, POST, PUT

- Kiểu JSON
--> JSON ARRAY []: Một mảng kiểu dữ liệu mong muốn
--> JSON OBJECT {}: Một đối tượng

- Có 2 cách truyền tham số
--> Tham số truyền trên URL (Query Param): tham số truyền trực tiếp trên URL" ?key=value&key=value --> Nếu tuân thủ nguyên tắc thì chỉ sủ dụng phương thức GET
--> Truyền ngầm: POST, PUT, DELETE



--> Done day 13,14,15,19